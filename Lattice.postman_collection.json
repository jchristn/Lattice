{
	"info": {
		"_postman_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
		"name": "Lattice",
		"description": "Lattice Document Store API\n\nLattice is a JSON document store with automatic schema detection, dynamic indexing, and SQL-like query capabilities.\n\n## Features\n- Automatic JSON schema detection and deduplication\n- Dynamic per-field indexing for fast queries\n- SQL-like DSL for document queries\n- Labels and tags for document organization\n- Full document content storage and retrieval\n\n## Getting Started\n1. Create a collection to organize your documents\n2. Ingest JSON documents into the collection\n3. Search and retrieve documents using filters or SQL expressions\n\n## Variables\n- `protocol`: HTTP protocol (default: http)\n- `hostname`: Server hostname (default: localhost)\n- `port`: Server port (default: 8000)",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"variable": [
		{
			"key": "protocol",
			"value": "http",
			"type": "string"
		},
		{
			"key": "hostname",
			"value": "localhost",
			"type": "string"
		},
		{
			"key": "port",
			"value": "8000",
			"type": "string"
		},
		{
			"key": "baseUrl",
			"value": "{{protocol}}://{{hostname}}:{{port}}",
			"type": "string"
		},
		{
			"key": "collectionId",
			"value": "",
			"type": "string",
			"description": "ID of the current collection (set automatically after creating a collection)"
		},
		{
			"key": "documentId",
			"value": "",
			"type": "string",
			"description": "ID of the current document (set automatically after creating a document)"
		},
		{
			"key": "schemaId",
			"value": "",
			"type": "string",
			"description": "ID of the current schema (set automatically after creating a document)"
		}
	],
	"item": [
		{
			"name": "Health",
			"description": "Health check endpoints to verify the server is running.",
			"item": [
				{
					"name": "Health Check (Root)",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/",
							"host": ["{{baseUrl}}"],
							"path": [""]
						},
						"description": "Basic health check at the root endpoint. Returns server status, version, and timestamp."
					},
					"response": []
				},
				{
					"name": "Health Check",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/v1.0/health",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "health"]
						},
						"description": "Health check endpoint. Returns server status, version, and timestamp.\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"statusCode\": 200,\n  \"data\": {\n    \"status\": \"Healthy\",\n    \"version\": \"1.0.0\",\n    \"timestamp\": \"2024-01-15T12:00:00Z\"\n  }\n}\n```"
					},
					"response": []
				}
			]
		},
		{
			"name": "Collections",
			"description": "Manage document collections. Collections are containers for organizing related documents.",
			"item": [
				{
					"name": "List Collections",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections"]
						},
						"description": "Retrieve all collections in the system.\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"statusCode\": 200,\n  \"data\": [\n    {\n      \"id\": \"col_abc123\",\n      \"name\": \"My Collection\",\n      \"description\": \"Collection description\",\n      \"documentsDirectory\": \"/path/to/docs\",\n      \"labels\": [\"production\"],\n      \"tags\": {\"env\": \"prod\"},\n      \"createdUtc\": \"2024-01-15T12:00:00Z\"\n    }\n  ]\n}\n```"
					},
					"response": []
				},
				{
					"name": "Create Collection",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 201) {",
									"    var jsonData = pm.response.json();",
									"    if (jsonData.data && jsonData.data.id) {",
									"        pm.collectionVariables.set(\"collectionId\", jsonData.data.id);",
									"        console.log(\"Set collectionId to: \" + jsonData.data.id);",
									"    }",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"name\": \"My Collection\",\n  \"description\": \"A collection for storing customer data\",\n  \"labels\": [\"production\", \"customers\"],\n  \"tags\": {\n    \"environment\": \"prod\",\n    \"team\": \"engineering\"\n  }\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections"]
						},
						"description": "Create a new collection for organizing documents.\n\n**Request Body:**\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| name | string | Yes | Collection name |\n| description | string | No | Collection description |\n| documentsDirectory | string | No | Custom directory for document storage |\n| labels | string[] | No | Labels for categorization |\n| tags | object | No | Key-value tags for metadata |\n\n**Response:** Returns the created collection with generated ID.\n\n**Note:** The collection ID is automatically saved to the `collectionId` variable for use in subsequent requests."
					},
					"response": []
				},
				{
					"name": "Get Collection",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}"]
						},
						"description": "Retrieve a specific collection by ID.\n\n**Path Parameters:**\n- `collectionId`: The unique identifier of the collection\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"statusCode\": 200,\n  \"data\": {\n    \"id\": \"col_abc123\",\n    \"name\": \"My Collection\",\n    \"description\": \"Collection description\",\n    \"createdUtc\": \"2024-01-15T12:00:00Z\"\n  }\n}\n```"
					},
					"response": []
				},
				{
					"name": "Check Collection Exists",
					"request": {
						"method": "HEAD",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}"]
						},
						"description": "Check if a collection exists without retrieving its data.\n\n**Path Parameters:**\n- `collectionId`: The unique identifier of the collection\n\n**Response:**\n- `200 OK`: Collection exists\n- `404 Not Found`: Collection does not exist"
					},
					"response": []
				},
				{
					"name": "Delete Collection",
					"request": {
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}"]
						},
						"description": "Delete a collection and all its documents.\n\n**Warning:** This action is irreversible. All documents in the collection will be permanently deleted.\n\n**Path Parameters:**\n- `collectionId`: The unique identifier of the collection\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"statusCode\": 200,\n  \"data\": {\n    \"message\": \"Collection deleted successfully\",\n    \"collectionId\": \"col_abc123\"\n  }\n}\n```"
					},
					"response": []
				},
				{
					"name": "Get Schema Constraints",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}/constraints",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}", "constraints"]
						},
						"description": "Get the field constraints defined for a collection.\n\n**Path Parameters:**\n- `collectionId`: The unique identifier of the collection\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"statusCode\": 200,\n  \"data\": [\n    {\n      \"id\": \"fco_abc123\",\n      \"collectionId\": \"col_xyz789\",\n      \"fieldPath\": \"email\",\n      \"dataType\": \"string\",\n      \"required\": true,\n      \"nullable\": false,\n      \"regexPattern\": \"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$\"\n    }\n  ]\n}\n```"
					},
					"response": []
				},
				{
					"name": "Update Schema Constraints",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"schemaEnforcementMode\": 1,\n  \"fieldConstraints\": [\n    {\n      \"fieldPath\": \"email\",\n      \"dataType\": \"string\",\n      \"required\": true,\n      \"nullable\": false,\n      \"regexPattern\": \"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$\"\n    },\n    {\n      \"fieldPath\": \"age\",\n      \"dataType\": \"integer\",\n      \"required\": false,\n      \"nullable\": true,\n      \"minValue\": 0,\n      \"maxValue\": 150\n    },\n    {\n      \"fieldPath\": \"status\",\n      \"dataType\": \"string\",\n      \"required\": true,\n      \"allowedValues\": [\"active\", \"inactive\", \"pending\"]\n    }\n  ]\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}/constraints",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}", "constraints"]
						},
						"description": "Update the schema enforcement mode and field constraints for a collection.\n\n**Schema Enforcement Modes:**\n- `0` (None): No validation, constraints are stored but not enforced\n- `1` (Strict): All constraints must pass or document ingestion fails\n- `2` (Flexible): Validation warnings are logged but documents are accepted\n- `3` (Partial): Only fields with defined constraints are validated\n\n**Field Constraint Properties:**\n| Field | Type | Description |\n|-------|------|-------------|\n| fieldPath | string | Dot-notation path to the field (e.g., `user.email`) |\n| dataType | string | Expected type: string, integer, number, boolean, array, object |\n| required | boolean | Field must be present |\n| nullable | boolean | Field can be null |\n| regexPattern | string | Regex pattern for string validation |\n| minValue | number | Minimum value for numbers |\n| maxValue | number | Maximum value for numbers |\n| minLength | integer | Minimum length for strings/arrays |\n| maxLength | integer | Maximum length for strings/arrays |\n| allowedValues | array | List of allowed values |\n| arrayElementType | string | Expected type of array elements |"
					},
					"response": []
				},
				{
					"name": "Get Indexing Configuration",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}/indexing",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}", "indexing"]
						},
						"description": "Get the indexed fields configured for a collection.\n\n**Path Parameters:**\n- `collectionId`: The unique identifier of the collection\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"statusCode\": 200,\n  \"data\": [\n    {\n      \"id\": \"ixf_abc123\",\n      \"collectionId\": \"col_xyz789\",\n      \"fieldPath\": \"email\",\n      \"createdUtc\": \"2024-01-15T12:00:00Z\"\n    }\n  ]\n}\n```"
					},
					"response": []
				},
				{
					"name": "Update Indexing Configuration",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"indexingMode\": 1,\n  \"indexedFields\": [\n    \"email\",\n    \"name\",\n    \"status\",\n    \"user.id\",\n    \"createdAt\"\n  ],\n  \"rebuildIndexes\": false\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}/indexing",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}", "indexing"]
						},
						"description": "Update the indexing mode and indexed fields for a collection.\n\n**Indexing Modes:**\n- `0` (All): Index all fields in documents (default behavior)\n- `1` (Selective): Only index the specified fields\n- `2` (None): Do not index any fields\n\n**Request Body:**\n| Field | Type | Description |\n|-------|------|-------------|\n| indexingMode | integer | Indexing mode (0=All, 1=Selective, 2=None) |\n| indexedFields | string[] | List of field paths to index (for Selective mode) |\n| rebuildIndexes | boolean | Whether to rebuild indexes after updating (default: false) |\n\n**Note:** Use dot-notation for nested fields (e.g., `user.email`)"
					},
					"response": []
				},
				{
					"name": "Rebuild Indexes",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"dropUnusedIndexes\": true\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}/indexes/rebuild",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}", "indexes", "rebuild"]
						},
						"description": "Rebuild indexes for a collection.\n\nThis operation re-processes all documents in the collection and rebuilds the indexes according to the current indexing configuration.\n\n**Request Body:**\n| Field | Type | Default | Description |\n|-------|------|---------|-------------|\n| dropUnusedIndexes | boolean | true | Remove index values for fields not in the indexed fields list (only applies when using Selective indexing mode) |\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"statusCode\": 200,\n  \"data\": {\n    \"documentsProcessed\": 1500,\n    \"indexesCreated\": 25,\n    \"indexesDropped\": 3,\n    \"valuesInserted\": 45000,\n    \"duration\": 2340,\n    \"errors\": [],\n    \"success\": true\n  }\n}\n```\n\n**Use Cases:**\n- After changing indexing mode from All to Selective\n- After updating the indexed fields list\n- To clean up unused index data\n- To recover from index corruption"
					},
					"response": []
				},
				{
					"name": "Create Collection (With Constraints)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 201) {",
									"    var jsonData = pm.response.json();",
									"    if (jsonData.data && jsonData.data.id) {",
									"        pm.collectionVariables.set(\"collectionId\", jsonData.data.id);",
									"        console.log(\"Set collectionId to: \" + jsonData.data.id);",
									"    }",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"name\": \"Validated Collection\",\n  \"description\": \"A collection with schema constraints and selective indexing\",\n  \"schemaEnforcementMode\": 1,\n  \"fieldConstraints\": [\n    {\n      \"fieldPath\": \"email\",\n      \"dataType\": \"string\",\n      \"required\": true,\n      \"nullable\": false,\n      \"regexPattern\": \"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$\"\n    },\n    {\n      \"fieldPath\": \"name\",\n      \"dataType\": \"string\",\n      \"required\": true,\n      \"minLength\": 1,\n      \"maxLength\": 100\n    },\n    {\n      \"fieldPath\": \"age\",\n      \"dataType\": \"integer\",\n      \"required\": false,\n      \"minValue\": 0,\n      \"maxValue\": 150\n    }\n  ],\n  \"indexingMode\": 1,\n  \"indexedFields\": [\n    \"email\",\n    \"name\",\n    \"status\"\n  ]\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections"]
						},
						"description": "Create a new collection with schema constraints and selective indexing.\n\nThis example creates a collection that:\n- Enforces strict schema validation (mode 1)\n- Requires valid email format for the `email` field\n- Requires `name` to be 1-100 characters\n- Validates `age` is between 0-150 (optional field)\n- Only indexes `email`, `name`, and `status` fields\n\n**Schema Enforcement Modes:**\n- `0` (None): No validation\n- `1` (Strict): All constraints must pass\n- `2` (Flexible): Warns but accepts documents\n- `3` (Partial): Only validates constrained fields\n\n**Indexing Modes:**\n- `0` (All): Index all fields\n- `1` (Selective): Only index specified fields\n- `2` (None): No indexing"
					},
					"response": []
				}
			]
		},
		{
			"name": "Documents",
			"description": "Manage JSON documents within collections. Documents are automatically indexed for fast querying.",
			"item": [
				{
					"name": "List Documents",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}/documents",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}", "documents"]
						},
						"description": "Retrieve all documents in a collection.\n\n**Path Parameters:**\n- `collectionId`: The unique identifier of the collection\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"statusCode\": 200,\n  \"data\": [\n    {\n      \"id\": \"doc_xyz789\",\n      \"collectionId\": \"col_abc123\",\n      \"schemaId\": \"sch_def456\",\n      \"name\": \"customer_001.json\",\n      \"labels\": [\"active\"],\n      \"tags\": {\"priority\": \"high\"},\n      \"createdUtc\": \"2024-01-15T12:00:00Z\"\n    }\n  ]\n}\n```\n\n**Note:** Document content is not included by default. Use Get Document with `includeContent=true` to retrieve content."
					},
					"response": []
				},
				{
					"name": "Create Document",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 201) {",
									"    var jsonData = pm.response.json();",
									"    if (jsonData.data && jsonData.data.id) {",
									"        pm.collectionVariables.set(\"documentId\", jsonData.data.id);",
									"        console.log(\"Set documentId to: \" + jsonData.data.id);",
									"    }",
									"    if (jsonData.data && jsonData.data.schemaId) {",
									"        pm.collectionVariables.set(\"schemaId\", jsonData.data.schemaId);",
									"        console.log(\"Set schemaId to: \" + jsonData.data.schemaId);",
									"    }",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"name\": \"customer_001.json\",\n  \"content\": {\n    \"Person\": {\n      \"First\": \"Joel\",\n      \"Last\": \"Christner\",\n      \"Email\": \"joel@example.com\"\n    },\n    \"Company\": \"Acme Corp\",\n    \"Active\": true,\n    \"Score\": 95.5,\n    \"Tags\": [\"premium\", \"verified\"]\n  },\n  \"labels\": [\"customer\", \"active\"],\n  \"tags\": {\n    \"priority\": \"high\",\n    \"region\": \"west\"\n  }\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}/documents",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}", "documents"]
						},
						"description": "Create (ingest) a new JSON document into a collection.\n\nLattice will automatically:\n1. Detect the JSON schema structure\n2. Create or reuse an existing schema\n3. Create dynamic index tables for each field\n4. Index all values for fast querying\n5. Store the raw JSON to disk\n\n**Request Body:**\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| content | object | Yes | The JSON document content |\n| name | string | No | Document name/filename |\n| labels | string[] | No | Labels for categorization |\n| tags | object | No | Key-value tags for metadata |\n\n**Response:** Returns the created document metadata.\n\n**Note:** The document ID and schema ID are automatically saved to variables for use in subsequent requests."
					},
					"response": []
				},
				{
					"name": "Create Document (Nested Example)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 201) {",
									"    var jsonData = pm.response.json();",
									"    if (jsonData.data && jsonData.data.id) {",
									"        pm.collectionVariables.set(\"documentId\", jsonData.data.id);",
									"    }",
									"    if (jsonData.data && jsonData.data.schemaId) {",
									"        pm.collectionVariables.set(\"schemaId\", jsonData.data.schemaId);",
									"    }",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"name\": \"order_001.json\",\n  \"content\": {\n    \"Order\": {\n      \"Id\": \"ORD-2024-001\",\n      \"Customer\": {\n        \"Name\": \"Alice Smith\",\n        \"Email\": \"alice@example.com\"\n      },\n      \"Items\": [\n        {\n          \"Product\": \"Widget A\",\n          \"Quantity\": 5,\n          \"Price\": 19.99\n        },\n        {\n          \"Product\": \"Widget B\",\n          \"Quantity\": 2,\n          \"Price\": 29.99\n        }\n      ],\n      \"Total\": 159.93,\n      \"Status\": \"pending\"\n    },\n    \"CreatedAt\": \"2024-01-15T12:00:00Z\"\n  },\n  \"labels\": [\"order\", \"pending\"],\n  \"tags\": {\n    \"source\": \"web\",\n    \"priority\": \"normal\"\n  }\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}/documents",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}", "documents"]
						},
						"description": "Example of ingesting a deeply nested JSON document with arrays.\n\nLattice handles:\n- Nested objects (flattened to dot-notation keys like `Order.Customer.Name`)\n- Arrays of primitives\n- Arrays of objects (each field indexed with position tracking)"
					},
					"response": []
				},
				{
					"name": "Get Document",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}/documents/{{documentId}}?includeContent=true",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}", "documents", "{{documentId}}"],
							"query": [
								{
									"key": "includeContent",
									"value": "true",
									"description": "Set to true to include the raw JSON document content"
								}
							]
						},
						"description": "Retrieve a specific document by ID.\n\n**Path Parameters:**\n- `collectionId`: The unique identifier of the collection\n- `documentId`: The unique identifier of the document\n\n**Query Parameters:**\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| includeContent | boolean | false | Include the raw JSON document content |\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"statusCode\": 200,\n  \"data\": {\n    \"id\": \"doc_xyz789\",\n    \"collectionId\": \"col_abc123\",\n    \"schemaId\": \"sch_def456\",\n    \"name\": \"customer_001.json\",\n    \"labels\": [\"active\"],\n    \"tags\": {\"priority\": \"high\"},\n    \"content\": \"{...}\",\n    \"createdUtc\": \"2024-01-15T12:00:00Z\"\n  }\n}\n```"
					},
					"response": []
				},
				{
					"name": "Get Document (Metadata Only)",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}/documents/{{documentId}}",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}", "documents", "{{documentId}}"]
						},
						"description": "Retrieve document metadata without the content. This is faster than including content.\n\n**Path Parameters:**\n- `collectionId`: The unique identifier of the collection\n- `documentId`: The unique identifier of the document"
					},
					"response": []
				},
				{
					"name": "Check Document Exists",
					"request": {
						"method": "HEAD",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}/documents/{{documentId}}",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}", "documents", "{{documentId}}"]
						},
						"description": "Check if a document exists without retrieving its data.\n\n**Path Parameters:**\n- `collectionId`: The unique identifier of the collection\n- `documentId`: The unique identifier of the document\n\n**Response:**\n- `200 OK`: Document exists\n- `404 Not Found`: Document does not exist"
					},
					"response": []
				},
				{
					"name": "Delete Document",
					"request": {
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}/documents/{{documentId}}",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}", "documents", "{{documentId}}"]
						},
						"description": "Delete a document from a collection.\n\n**Warning:** This action is irreversible.\n\n**Path Parameters:**\n- `collectionId`: The unique identifier of the collection\n- `documentId`: The unique identifier of the document\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"statusCode\": 200,\n  \"data\": {\n    \"message\": \"Document deleted successfully\",\n    \"documentId\": \"doc_xyz789\"\n  }\n}\n```"
					},
					"response": []
				}
			]
		},
		{
			"name": "Search",
			"description": "Search and query documents using filters or SQL-like expressions.",
			"item": [
				{
					"name": "Search (Structured Filters)",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"filters\": [\n    {\n      \"field\": \"Person.First\",\n      \"condition\": \"Equals\",\n      \"value\": \"Joel\"\n    }\n  ],\n  \"maxResults\": 100,\n  \"skip\": 0,\n  \"ordering\": \"CreatedDescending\",\n  \"includeContent\": false,\n  \"includeLabels\": true,\n  \"includeTags\": true\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}/documents/search",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}", "documents", "search"]
						},
						"description": "Search documents using structured filters.\n\n**Request Body:**\n| Field | Type | Description |\n|-------|------|-------------|\n| filters | array | Array of filter objects |\n| labels | string[] | Filter by labels (documents must have all) |\n| tags | object | Filter by tags (documents must have all) |\n| maxResults | number | Maximum results (default: 100, max: 1000) |\n| skip | number | Number of results to skip for pagination |\n| ordering | string | Result ordering (see below) |\n| includeContent | boolean | Include document content (default: false) |\n| includeLabels | boolean | Include document labels (default: true) |\n| includeTags | boolean | Include document tags (default: true) |\n\n**Filter Conditions:**\n- `Equals`, `NotEquals`\n- `GreaterThan`, `GreaterThanOrEqualTo`\n- `LessThan`, `LessThanOrEqualTo`\n- `Contains`, `StartsWith`, `EndsWith`\n- `IsNull`, `IsNotNull`\n\n**Ordering Options:**\n- `CreatedAscending`, `CreatedDescending`\n- `LastUpdateAscending`, `LastUpdateDescending`\n- `NameAscending`, `NameDescending`"
					},
					"response": []
				},
				{
					"name": "Search (SQL Expression)",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"sqlExpression\": \"SELECT * FROM documents WHERE Person.First = 'Joel' AND Active = 'true' ORDER BY createdutc DESC LIMIT 10\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}/documents/search",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}", "documents", "search"]
						},
						"description": "Search documents using SQL-like expression.\n\n**SQL Syntax:**\n```sql\nSELECT * FROM documents\nWHERE field = 'value'\nAND field2 > 100\nORDER BY createdutc DESC\nLIMIT 10\nOFFSET 0\n```\n\n**Supported Operators:**\n- `=`, `!=`, `<>` (equality)\n- `>`, `>=`, `<`, `<=` (comparison)\n- `LIKE '%value%'` (contains)\n- `LIKE 'value%'` (starts with)\n- `LIKE '%value'` (ends with)\n- `IS NULL`, `IS NOT NULL`\n\n**Supported ORDER BY Fields:**\n- `createdutc`\n- `lastupdateutc`\n- `name`\n\n**Note:** Use dot notation for nested fields (e.g., `Person.First`)"
					},
					"response": []
				},
				{
					"name": "Search (Multiple Filters)",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"filters\": [\n    {\n      \"field\": \"Company\",\n      \"condition\": \"Contains\",\n      \"value\": \"Corp\"\n    },\n    {\n      \"field\": \"Active\",\n      \"condition\": \"Equals\",\n      \"value\": \"true\"\n    },\n    {\n      \"field\": \"Score\",\n      \"condition\": \"GreaterThan\",\n      \"value\": \"80\"\n    }\n  ],\n  \"maxResults\": 50,\n  \"includeContent\": true\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}/documents/search",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}", "documents", "search"]
						},
						"description": "Search with multiple filters (AND logic).\n\nAll filter conditions must match for a document to be included in results."
					},
					"response": []
				},
				{
					"name": "Search (By Labels)",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"labels\": [\"customer\", \"active\"],\n  \"maxResults\": 100\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}/documents/search",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}", "documents", "search"]
						},
						"description": "Search for documents that have specific labels.\n\nDocuments must have ALL specified labels to match."
					},
					"response": []
				},
				{
					"name": "Search (By Tags)",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"tags\": {\n    \"priority\": \"high\",\n    \"region\": \"west\"\n  },\n  \"maxResults\": 100\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}/documents/search",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}", "documents", "search"]
						},
						"description": "Search for documents that have specific tags.\n\nDocuments must have ALL specified tag key-value pairs to match."
					},
					"response": []
				},
				{
					"name": "Search (Pagination)",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"maxResults\": 10,\n  \"skip\": 20,\n  \"ordering\": \"CreatedDescending\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}/documents/search",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}", "documents", "search"]
						},
						"description": "Paginated search example.\n\nThis request retrieves page 3 (results 21-30) with 10 results per page.\n\n**Pagination:**\n- Page 1: `skip=0, maxResults=10`\n- Page 2: `skip=10, maxResults=10`\n- Page 3: `skip=20, maxResults=10`\n\n**Response includes:**\n- `totalRecords`: Total matching documents\n- `endOfResults`: Boolean indicating if this is the last page\n- `recordsRemaining`: Number of records after this page"
					},
					"response": []
				},
				{
					"name": "Search (Fast - No Labels/Tags)",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"filters\": [\n    {\n      \"field\": \"Active\",\n      \"condition\": \"Equals\",\n      \"value\": \"true\"\n    }\n  ],\n  \"maxResults\": 1000,\n  \"includeContent\": false,\n  \"includeLabels\": false,\n  \"includeTags\": false\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/v1.0/collections/{{collectionId}}/documents/search",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "collections", "{{collectionId}}", "documents", "search"]
						},
						"description": "Performance-optimized search that excludes labels and tags.\n\nSetting `includeLabels` and `includeTags` to `false` eliminates additional database queries, providing significant speedups (up to 2-3x faster for large result sets).\n\nUse this when you only need document metadata without labels or tags."
					},
					"response": []
				}
			]
		},
		{
			"name": "Schemas",
			"description": "View automatically detected JSON schemas. Schemas are created during document ingestion and reused when documents have identical structures.",
			"item": [
				{
					"name": "List Schemas",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/v1.0/schemas",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "schemas"]
						},
						"description": "Retrieve all schemas in the system.\n\nSchemas are automatically created when documents are ingested. Documents with identical JSON structures share the same schema (deduplicated by hash).\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"statusCode\": 200,\n  \"data\": [\n    {\n      \"id\": \"sch_def456\",\n      \"hash\": \"a1b2c3d4...\",\n      \"createdUtc\": \"2024-01-15T12:00:00Z\"\n    }\n  ]\n}\n```"
					},
					"response": []
				},
				{
					"name": "Get Schema",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/v1.0/schemas/{{schemaId}}",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "schemas", "{{schemaId}}"]
						},
						"description": "Retrieve a specific schema by ID.\n\n**Path Parameters:**\n- `schemaId`: The unique identifier of the schema"
					},
					"response": []
				},
				{
					"name": "Get Schema Elements",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/v1.0/schemas/{{schemaId}}/elements",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "schemas", "{{schemaId}}", "elements"]
						},
						"description": "Retrieve the elements (fields) of a schema.\n\nSchema elements describe each field in the JSON structure, including:\n- Key name (dot notation for nested fields)\n- Data type (string, integer, number, boolean, null, array<T>)\n- Position in the schema\n- Nullability\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"statusCode\": 200,\n  \"data\": [\n    {\n      \"id\": \"sel_001\",\n      \"schemaId\": \"sch_def456\",\n      \"position\": 0,\n      \"key\": \"Person.First\",\n      \"dataType\": \"string\",\n      \"nullable\": false\n    },\n    {\n      \"id\": \"sel_002\",\n      \"schemaId\": \"sch_def456\",\n      \"position\": 1,\n      \"key\": \"Person.Last\",\n      \"dataType\": \"string\",\n      \"nullable\": false\n    }\n  ]\n}\n```"
					},
					"response": []
				}
			]
		},
		{
			"name": "Index Tables",
			"description": "View index table mappings. Lattice creates a dedicated index table for each unique field (key) across all documents for fast querying.",
			"item": [
				{
					"name": "List Index Tables",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/v1.0/tables",
							"host": ["{{baseUrl}}"],
							"path": ["v1.0", "tables"]
						},
						"description": "Retrieve all index table mappings.\n\nLattice creates a dedicated database table for each unique field (key) found in documents. This enables fast equality and range queries on any indexed field.\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"statusCode\": 200,\n  \"data\": [\n    {\n      \"id\": \"itm_001\",\n      \"key\": \"Person.First\",\n      \"tableName\": \"idx_a1b2c3d4\",\n      \"createdUtc\": \"2024-01-15T12:00:00Z\"\n    },\n    {\n      \"id\": \"itm_002\",\n      \"key\": \"Person.Last\",\n      \"tableName\": \"idx_e5f6g7h8\",\n      \"createdUtc\": \"2024-01-15T12:00:00Z\"\n    }\n  ]\n}\n```\n\n**Note:** Table names are MD5 hashes of the key names to ensure valid SQL identifiers."
					},
					"response": []
				}
			]
		}
	]
}
